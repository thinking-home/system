*ThinkingHome.Core.Plugins*

[![NuGet Pre Release](https://img.shields.io/nuget/vpre/ThinkingHome.Core.Plugins.svg)]()

Этот пакет содержит классы, реализующие базовые возможности плагинов.
Если вы хотите написать новый плагин, вам нужно [подключить](https://www.nuget.org/packages/ThinkingHome.Core.Plugins) этот пакет в свой проект.

## Создание нового плагина

Создайте в своем проекте новый класс, унаследованный от `ThinkingHome.Core.Plugins.PluginBase`. `PluginBase` - это абстрактный класс, который содержит общую функциональность для всех плагинов: логирование, настройки, локализация, взаимодействие с другими плагинами.

```csharp
using Microsoft.Extensions.Logging;
using ThinkingHome.Core.Plugins;
...

public class MyPlugin : PluginBase
{
    public override void InitPlugin()
    {
        Logger.LogInformation($"my plugin: init");
    }
}
```

Чтобы подключить сборку с плагином в систему, добавьте её название в список `assemblies` в файле appsettings.json.
При старте система автоматически найдет все доступные плагины внутри перечисленных сборок и создает экземпляр каждого из них.

## Жизненный цикл плагина

В базовом классе `PluginBase` описаны виртуальные методы `InitPlugin`, `StartPlugin` и `StopPlugin`.
Они автоматически вызываются на нужном этапе работы плагина. Вы можете переопределить их и добавить туда собственную логику.

### Инициализация

Метод `InitPlugin` вызывается у каждого плагина при старте приложения. Это подходящее место, чтобы задать начальное состояние плагина.

Обращаясь из метода `InitPlugin` к другим плагинам, помните, что в этот момент они еще не проинициализированы.


```csharp
public virtual void InitPlugin() { ... }
```

### Запуск

Метод `StartPlugin` вызывается когда все плагины проинициализированы. Здесь можно подписаться на события других плагинов или запустить нужные дочерние потоки.


```csharp
public virtual void StartPlugin() { ... }
```

### Остановка

Метод `StopPlugin` вызывается при остановке приложения. Здесь можно сохранить несохраненные рабочие данные и освободить занятые ресурсы.


```csharp
public virtual void StopPlugin() { ... }
```

## Взаимодействие плагинов

Каждый плагин может обращаться к экземплярам других плагинов, вызывать их открытые (public) методы и подписываться на события. 

Экземпляр другого плагина можно получить через свойство `Context` базового класса `PluginBase`. 
Это свойство содержит специальный объект, реализующий интерфейс `ThinkingHome.Core.Plugins.IServiceContext`. 
Для получения экземпляра другого плагина используйте метод `TPlugin Require<TPlugin>()`. Помните, перед использованием 
другого плагина нужно добавить в свой проект ссылку на сборку, в которой он находится.

```csharp
OtherPlugin plugin = Context.Require<OtherPlugin>();

plugin.ExecuteSomeMethod();
```

Метод `IReadOnlyCollection<PluginBase> GetAllPlugins()` возвращает коллекцию всех плагинов, доступных в приложении.

```csharp
// вывод в лог названий всех доступных плагинов
foreach (PluginBase plugin in Context.GetAllPlugins())
{
    var pluginTypeName = plugin.GetType().FullName;
    
    Logger.LogInformation(pluginTypeName);
}
```

### Подписка на события плагинов

Плагины могут подписываться на события друг друга. Например, плагин "будильник" может подписаться на событие
"срабатывание таймера" плагина "таймер" и, если наступило нужное время, подать звуковой сигнал.

Плагин, который генерирует событие, в начале своей работы должен найти и запомнить все доступные обработчики этого события - методы других плагинов. 

Чтобы отметить метод плагина как обработчик события, удобно использовать атрибуты. С помошью атрибута можно задать
дополнительные параметры для обработчика события.

Чтобы плагин, генерирующий событие, мог легко найти методы других плагинов, отмеченных заданным атрибутом, 
он может использовать метод расширения `FindMethods`, для класса `PluginBase`.
 
```csharp
(TAttr Meta, TDelegate Method)[] FindMethods<TAttr, TDelegate>(this PluginBase plugin)
``` 
 
В метод `FindMethods` нужно передать тип атрибута, который нужно найти, и делегат, определяющий сигнатуру методов.
На выходе вы получите массив, каждый элемент которого имеет поля:  
 
- `Method` – ссылка на найденный обработчик события, отмеченный атрибутом
- `Meta` – атрибут, которым отмечен обработчик события 

#### Пример

```csharp
// плагин, который обрабатывает событие
public class Plugin1: PluginBase
{
    [MyAttribute]
    public void OnMyEvent()
    {
        // обработка события
    }
}

// плагин, который генерирует событие
public class Plugin2: PluginBase
{
    private Action[] handlers;

    // инициализация
    public override void InitPlugin()
    {
        // ищем все обработчики и запоминаем в поле плагина
        handlers = Context.GetAllPlugins()                          // получаем список плагинов
            .SelectMany(p => p.FindMethods<MyAttribute, Action>())  // ищем все обработчики во всех плагинах
            .Select(obj => obj.Method)                              // достаем метод из поля Method
            .ToArray();
    }
    
    public void TestMethod()
    {
        // когда нужно сгенерировать событие,
        // вызываем найденные обработчики
        foreach(var handler in handlers)
        {
            handler();
        } 
    }
}
```

### Безопасный вызов обработчиков

Внутри обработчика события может произойти ошибка и, если плагин корректно её не обработает, его работа прервется и все последующие обработчики не будут выполнены.

Для безопасного вызова обработчиков событий в базовом классе плагина есть метод `SafeInvoke`. В нем есть проверка обработчика на равенство `null`
и обработка исключений с записью в лог информации о них. Также есть возможность асинхронного параллельного выполнения обработчиков.  


```csharp
SafeInvoke(handlers, h => h(task.TaskId), true);
```

Параметры:

1. Обработчик события (делегат) или коллекция обработчиков. 
1. Действие, которое нужно выполнить для каждого обработчика (например, вызвать его с заданными аргументами). 
1. Логическое значение: если оно равно `true`, то обработчики будут вызваны асинхронно. По умолчанию, параметр равен `false`. 

## Логирование

Плагинам доступны инструменты для логирования (используется пакет [Microsoft.Extensions.Logging](https://www.nuget.org/packages/Microsoft.Extensions.Logging/)).

В базовом классе `PluginBase` есть свойство `Logger` (`Microsoft.Extensions.Logging.ILogger`). Используйте его методы для записи в лог.

```csharp
using Microsoft.Extensions.Logging;

public class MyPlugin: PluginBase
{
    public override void InitPlugin()
    {
        Logger.LogInformation("Hello world!");
    }
}
```

Для записи логируемой информации в конкретное место назначения (в консоль, файл, базу данных и др.) 
используется библиотека [Serilog](https://serilog.net). Её параметры находятся в файле с настройками 
системы [appsettings.json](#Настройки). По умолчанию настроен вывод информации в консоль и сохранение
в текстовый файл в папке `logs`. Узнать подробнее о настройках библиотеки Serilog вы можете 
в [документации](https://github.com/serilog/serilog-settings-configuration).

## Локализация

свойство StringLocalizer (Microsoft.Extensions.Localization), выбор языка - в настройках, resx с названием плагина в папке Lang, должен быть язык по умолчанию


## Настройки

Настройки хранятся в файле appsettings.json. Разделы: 

- язык - строка,
- логирование - логгер serilog, сборки, настройки плагинов.


